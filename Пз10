#include <algorithm>
#include <string>
#include <vector>
#include <iostream>
using namespace std;


/// Элемент дерева

struct Node
{
    int val;                                        // значение
    Node* greater;                                  // ссылка на больший элемент
    Node* less;                                     // ссылка на меньший элемент

    Node(int _val) : val(_val), greater(nullptr), less(nullptr) {}    // конструктор
};


/// Бинарное дерево

struct list
{
    Node* first;                                    // Первый элемент

    list() : first(nullptr) {}                      // Конструктор


    /// Пустой ли список
    bool isEmpty() {
        return first == nullptr;
    }


    /// Добавляет элемент в дерево

    void Insert(int val) {
        Node* p = new Node(val);                    // Новый элемент

        if (isEmpty())                             
        {
            first = p;                              
            return;
        }

        Node* tmp = first;                          // Элемент, с которым будем сравнивать
        while (true)
        {
            if (p->val >= tmp->val)                 // Если нужно сдвинуться по дереву вправо
            {
                if (tmp->greater == nullptr)        // Если там пусто
                {
                    tmp->greater = p;               // Ставим наш элемент туда
                    break;
                }
                tmp = tmp->greater;                 // А если нет, сдвигаемся на этот элемент
            }
            else                                    // Если нужно сдвинуться по дереву влево
            {
                if (tmp->less == nullptr)           // И там пусто
                {
                    tmp->less = p;                  // Ставим элемент туда
                    break;
                }
                tmp = tmp->less;                    // А если нет, сдвигаемся на этот элемент 
            }
        }
    }

    /// Получить максимальный элемент дерева и удалить его

    int Extract() {
        int answer = 0;                             // Ответ
        Node* prev = first;                         // Предыдущий элемент
        Node* tmp = first;                          // Текущий элемент

        if (tmp->greater == nullptr)                // Если это максимальный элемент дерева
        {
            answer = tmp->val;                      // Записываем ответ
            tmp = tmp->less;                        // Ставим на его место меньший элемент
            first = tmp;                            // И говорим что это первый элемент
            
            return answer;                          // Возвращаем ответ
        }

        while (tmp->greater != nullptr)             // Пока элемент не макимальный
        {
            prev = tmp;                             // Сохраняем текущий элемент
            tmp = tmp->greater;                     // Берем больший элемент
        }

        
        
        answer = tmp->val;                          // В ответ записываем значение максимального элемнта
        tmp = tmp->less;                            // На его мето ставим меньший элемнт (если он есть)
        prev->greater = tmp;                        // Ставим указатель на меньший элемент (теперь он больший)
        return answer;                              
    }


    /// Находит элемент по его значению


    string Find(int val) {
        Node* tmp = first;                                      // Текущий элемент

        while (tmp->val != val)                                 // Пока значение не равно нужному
        {
            if (val > tmp->val && tmp->greater != nullptr)      // Если нужно сдвинуться вправо и там есть куда
            {
                tmp = tmp->greater;                             // Сдвигаемся
            }
            else if (val < tmp->val && tmp->less != nullptr)    // Если нужно сдвинуться влево и там есть куда
            {
                tmp = tmp->less;                                // Сдвигаемся
            }
            else {
                return "NO";                                    // А если не можем сдвинуться, то пишем что такого элемента нет
            }
        }

        return "YES";       // А если получилось найти, то пишем, что можем найти
    }
};


int main()
{
    list lst;                                   
    int n;                                     

    cout << "Скок команд? ";
    cin >> n;                                   // Получаем количество комманд


    vector<int> cmd1;                           
    vector<int> cmd2;

    for (int i = 0; i < n; i++)                 
    {
        int input1, input2 = 0;                 
        cin >> input1;                          // Считываем первую команду

        if (input1 > 2 || input1 < 0)           
        {
            cout << "ОТ 0 ДО 2";
            return 1;
        }

        if (input1 != 1)                       
        {
            cin >> input2;                      // Получаем второе число
        }
        
        cmd1.push_back(input1);                 // Записываем в вектора команды
        cmd2.push_back(input2);                 // Если команда под номером 1, то в cmd2 будет храниться число 0
        
    }

    cout << endl;                      

    for (int i = 0; i < n; i++)                 
    {
        switch (cmd1[i])                        
        {
        case 0:
            lst.Insert(cmd2[i]);
            break;
        case 1:
            cout << lst.Extract() << endl;
            break;
        case 2:
            cout << lst.Find(cmd2[i]) << endl;
            break;
        default:                                
            cout << "Чо?";
            return 1;
        }
    }
}
